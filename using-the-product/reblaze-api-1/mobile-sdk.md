# Mobile SDK

## Introduction

Reblaze provides an SDK for use in mobile/native applications, available for both iOS and Android. Customers rebuild and publish their applications with the SDK embedded.

The Reblaze SDK supports several languages and frameworks:

**Android**:

* Java
* React Native

**iOS**

* Swift \(Xcode 11\)
* Objective-C \(Xcode 11\)
* React Native

Code samples for each are provided below. 

In the discussion that follows, **customer** will refer to the organization who uses the Reblaze SDK, **client application** will refer to the application in which the SDK is used, and **user** will refer to the end user of the client application.

### Benefits

The SDK provides client authentication: it signs the application, authenticates the device, and verifies user identity. All communications occur over TLS and include an HMAC signature to harden communications between the application and the microservice/API endpoint. The signatures are non-reproducible, non-guessable, and non-repeating. They provide a reliable, secure mechanism to verify that the packets are originating from a legitimate app user, and not from an emulator or other bot. 

The SDK also sends events to Reblaze:

* **Those generated automatically by the user's interaction** with the client application. \(An internal thread accumulates events and sends them to Reblaze every 12 seconds.\) The default events currently gathered by Reblaze are:
  * for Android: `click, gesture, keydown, keyPress, keyUp, touchDown, touchMove, touchUp`
  * for iOS: `click, deviceOrientation, gesture, keyDown, keyPress, keyUp, touchDown, touchMove, touchUp`
* **Optional custom events** generated and sent programmatically by the application. \(These are added to the same queue that the default events use.\)

Reblaze uses these events to build behavioral profiles for users of the client application. After an initial learning period, Reblaze will understand how legitimate users interact with the application. 

Subsequent users who do not conform to these behavioral patterns can be flagged as suspicious and/or **blocked from access to the API endpoint.** 

This provides an additional layer of security, based on private analytics and cumulative user-event data to which threat actors have no access. Thus, it provides an additional form of client authentication that is extremely difficult for threat actors to defeat.

### Sending custom events: Optional, but highly recommended

Customers can evaluate the types of custom events their applications send programmatically to Reblaze. Each is identified with a string chosen by the customer. Sending more types has the following benefits:

* **Reblaze can construct more sophisticated behavioral profiles**, and thus can enforce more robust security policies. **Example:** a mobile API endpoint is receiving numerous requests for data from a specific IP address. Those requests for data are usually generated by a user interacting with the customer's application in a certain way. **If the customer has coded the application so that all these interactive events are sent to Reblaze, then Reblaze will have learned that these types of data requests should be accompanied by these specific custom events.** A high number of data requests that are _not_ accompanied by these event notifications would indicate that this is not a legitimate user; instead, it is probably an attacker using an emulator. 
* **Reblaze includes all the custom events in its traffic logs.** Thus, customers can view fuller records of all the events being generated by each user.

### **How to sign/authenticate client requests and events**

When the application sends events and application data upstream to Reblaze, the calls must include certain authentication arguments. 

During initialization, the application activates the SDK with some variation of the following call, depending on OS and language. \(This example is in React Native\).

```java
reblaze.start(
	"<YOUR-APP-DOMAIN>", 
	"<YOUR-SECRET>", 
	"<YOUR-USER-KEY-NAME>",	
	"<YOUR-USER-KEY-VALUE>");
```

{% hint style="info" %}
The names above are placeholders. In your code, they should be replaced by actual values.
{% endhint %}

For example:

```java
reblaze.start(
	"https://api.example.com", 
	"abcde09876", 
	"UserName",	
	"jsmith@gmail.com");
```

There are four authentication arguments, some of which are also used in other calls to Reblaze. 

| Argument | Description |
| :--- | :--- |
| YOUR-APP-DOMAIN | URL for the customer's application server. |
| YOUR-SECRET | Secret value issued to the customer by Reblaze. |
| YOUR-USER-KEY-NAME | The name of a field that contains a unique value for this user. \(**Example**: UserName.\) |
| YOUR-USER-KEY-VALUE | The value for the field specified above. \(For example, the user's email address.\) |

Reblaze uses the first two arguments to identify the application. Reblaze protects the customer's API endpoint\(s\) using the security rulesets defined for this application, and also based on the behavioral data accumulated for all users of this application.

The second two arguments identify the individual end user. Reblaze uses this to enforce per-user security rulesets such as dynamic rate limits. These arguments also allow you to observe the activities of individual users within the traffic logs.

## Overview of SDK Usage

To use the Reblaze SDK, up to six tasks must be done. \(The various combinations of OS and language/framework require different combinations of tasks.\) The first and last tasks are at the project level; the remaining tasks are done within your application's code.

* [Installation](mobile-sdk.md#installation) 
* [Initialize/instantiate the SDK](mobile-sdk.md#initialize-instantiate-the-sdk)
* [Sign your application's requests](mobile-sdk.md#sign-your-applications-requests)
* [Send custom events](mobile-sdk.md#send-custom-events) ****\(optional\)
* [Destroy/cleanup resources](mobile-sdk.md#destroy-cleanup-resources)
* [Prepare the project for publishing](mobile-sdk.md#prepare-the-application-for-publishing) \(iOS only\)

Each step is explained below. 

## Installation

### Android

#### Java

To install the SDK library into your project, copy the`.arr` file \(**reblaze-release.arr**\) from the **app/libs** folder into your project libs folder. 

In your app's Gradle script, in the dependencies section, add the following line:

```java
implementation(name:'reblaze-release', ext:'aar')
```

Also make sure that the dependencies section includes this:

```java
implementation fileTree(dir: 'libs', include: ['*.jar'])
```

#### React Native

Open `android/app/src/main/java/[...]/MainActivity.java`

* At the top of the file, add this to the imports: 

```java
import com.reactlibrary.RNReblazeReactNativeSdkPackage; 
```

* To the list returned by the`getPackages()` method, add this:

```java
Add new RNReblazeReactNativeSdkPackage()
```

Append the following to `android/settings.gradle`:

```java
include ':reblaze-sdk' project(':react-native-reblaze-react-native-sdk').projectDir = new File( rootProject.projectDir, '../node_modules/react-native-reblaze-react-native-sdk/android')
```

Open `android/app/build.gradle`. 

* Inside the dependencies block, insert this: 

```java
compile project(':react-native-reblaze-react-native-sdk') include ':react-native-reblaze-react-native-sdk' project(':react-native-reblaze-react-native-sdk').projectDir = new File( rootProject.projectDir, '../node_modules/react-native-reblaze-react-native-sdk/android')
```

* Inside the dependencies block, insert this:

```java
compile project(':re-sdk')
```

* Then add this:

```java
allprojects { repositories { mavenLocal() google() jcenter() maven { // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url "$rootDir/../node_modules/react-native/android" } flatDir { dirs project(':reblaze-sdk').file('reblaze-release') // Reblaze Added line for gradle to find the compiled library } } }
```

In the Javascript file `index.js (app)`, add this line :

```java
AppRegistry.registerComponent('RNReblazeReactNativeSDK', () => App);
```

### iOS

#### Swift **and Objective C**

Find the **ReblazeSDK.framework** inside the example app folder. Copy/Drag the Universal Framework to this project. While copying the framework in Project Explorer, check “Copy items if needed”.

Select the Project, and choose `Target → Project Name → Select General` → Scroll to **Embedded Binaries**. Press **+** and Add the framework.

#### React Native

1. Download all files from the repository.
2. Manually link them as explained here: [https://facebook.github.io/react-native/docs/linking-libraries-ios](https://facebook.github.io/react-native/docs/linking-libraries-ios)

## **Initialize/instantiate the SDK**

### **Android**

#### **Java**

```java
reblaze.start(this, 
	"<YOUR-APP-DOMAIN>", 
	"<YOUR-SECRET>", 
	"<YOUR-USER-KEY-NAME>",
	"<YOUR-USER-KEY-VALUE>");
```

The `reblaze` class is static, so you can call it from anywhere in the app. The best practice is to make this call within `MainActivity`.

#### React Native

```java
import reblaze from 'reblaze-sdk';
```

```java
reblaze.start(
	"<YOUR-APP-DOMAIN>", 
	"<YOUR-SECRET>", 
	"<YOUR-USER-KEY-NAME>",	
	"<YOUR-USER-KEY-VALUE>");
```

### iOS

#### Swift

```java
import ReblazeSDK
```

This should be in your `AppDelegate` and wherever you want to send a custom event.

```java
Reblaze.start(
          with: "<YOUR-APP-DOMAIN>", 
        secret: "<YOUR-SECRET>", 
   header_name: "<YOUR-USER-KEY-NAME>", 
  header_value: "<YOUR-USER-KEY-VALUE>")
```

The `reblaze` class is static, so you can call it from anywhere in the app. The best practice is to make this call within `AppDelegate`.

#### Objective-C

```java
@import ReblazeSDK;
```

This should be in your `AppDelegate` and wherever you want to send a custom event.

```java
[Reblaze startWith:@"<YOUR-APP-DOMAIN>"
            secret:@"<YOUR-SECRET>"
       header_name:@"<YOUR-USER-KEY-NAME>"
      header_value:@"<YOUR-USER-KEY-VALUE>"
    shouldShowLogs:YES];
```

`application:didFinishLaunchingWithOptions` is a good location for this.

#### React Native

```java
import reblaze from 'reblaze-sdk';
```

```java
reblaze.start(
	"<YOUR-APP-DOMAIN>", 
	"<YOUR-SECRET>", 
	"<YOUR-USER-KEY-NAME>",	
	"<YOUR-USER-KEY-VALUE>");
```

## **Sign your application's requests**

Whenever your application sends a request upstream to your API endpoint, the request must include three headers for Reblaze to authenticate the client.

The headers are:

1. `timestamp` : unix/epoch timestamp of the current time \(seconds since January 1, 1970\).
2. the value provided in the `<YOUR-USER-KEY-NAME>` argument
3. `rbzid` : the signature generated by the Reblaze SDK. This is a string provided by the static method `getHash`. There are slight differences in syntax across languages/frameworks, described below.

{% hint style="warning" %}
Note that one of the headers is a timestamp, and another is generated from a timestamp. **Both headers must use the same timestamp.** In other words, your code should take a timestamp and save it. Then it should be submitted directly in the first header, and used as the basis for the third header.
{% endhint %}

Here's an example of obtaining the timestamp using Objective C.

```java
NSTimeInterval timestamp = [[[NSDate alloc] init] timeIntervalSince1970];
NSString *hash = [Reblaze getHashWithUnixTimestamp:ceil(timestamp)];
```

{% hint style="warning" %}
Make sure that `getHash` is called only **after** `start` or `startWith` is called.
{% endhint %}

### Android

#### Java

```
reblaze.getHash(unix_timestamp)
```

### **iOS**

#### **Swift**

```java
Reblaze.getHash(unixTimestamp: Int)
```

#### **Objective-C**

```java
[Reblaze getHashWithUnixTimestamp:<Int>];
```

## **Send custom events**

The names of custom events are defined by your application. Whatever strings you choose for them are stored and displayed by Reblaze within the traffic logs.

### Android

#### Java

```java
reblaze.sendEvent("<YOUR-EVENT-NAME-STRING>")
```

**React Native**

```java
reblaze.sendEvent("<YOUR-EVENT-NAME-STRING>");
```

### **iOS**

#### **Swift** 

```java
Reblaze.sendEvent(eventName: "<YOUR-EVENT-NAME-STRING>")
```

#### **Objective C**

```java
[Reblaze sendEventWithEventName:@"<YOUR-EVENT-NAME-STRING>"];
```

#### **React Native**

```java
reblaze.sendEvent("<YOUR-EVENT-NAME-STRING>");
```

\*\*\*\*

## **Destroy/cleanup resources**

When the SDK is instantiated, it spins up a thread to gather and send events and requests to Reblaze. In Java, when the user's session is complete you should terminate the thread.

### Android

#### Java

```java
reblaze.Destroy()
```

{% hint style="info" %}
The best practice is to place this call within the application's onDestroy\(\) method.
{% endhint %}

#### React Native

Cleanup is not necessary.

### iOS

#### **Swift, Objective-C, and** React Native

Cleanup is not necessary.

## Prepare the Project for Publishing

{% hint style="info" %}
**This only applies to iOS applications.** Android applications do not require this step.
{% endhint %}

Before publishing an application to the App Store, you must remove unused architectures. This is done by adding the Remove Unused Architectures Script to your project.

**Remove Unused Architectures script**

Take the script shown below. Select the Project, Choose **Target → Project Name → Select Build Phases → Press “+” → New Run Script Phase.  → Name** the  script as **Remove Unused Architectures Script**.

```text
FRAMEWORK="TestFramework"
FRAMEWORK_EXECUTABLE_PATH="${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/$FRAMEWORK.framework/$FRAMEWORK"
EXTRACTED_ARCHS=()

for ARCH in $ARCHS
do
    lipo -extract "$ARCH" "$FRAMEWORK_EXECUTABLE_PATH" -o "$FRAMEWORK_EXECUTABLE_PATH-$ARCH"
    EXTRACTED_ARCHS+=("$FRAMEWORK_EXECUTABLE_PATH-$ARCH")
done

lipo -o "$FRAMEWORK_EXECUTABLE_PATH-merged" -create "${EXTRACTED_ARCHS[@]}"
rm "${EXTRACTED_ARCHS[@]}"
rm "$FRAMEWORK_EXECUTABLE_PATH"
mv "$FRAMEWORK_EXECUTABLE_PATH-merged" "$FRAMEWORK_EXECUTABLE_PATH"
```

This will remove unused Simulator architectures while the application is pushed to the App Store.







